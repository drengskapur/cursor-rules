---
description: "Storybook v7.6 component development and documentation standards"
globs: ["**/*.stories.{ts,tsx}", "**/*.mdx", ".storybook/**/*"]
---

# Storybook Standards

## Configuration

### Base Setup
```yaml
requirements:
  version: "^7.6.0"
  dependencies:
    - "@storybook/react"
    - "@storybook/addon-essentials"
    - "@storybook/addon-interactions"
    - "@storybook/addon-a11y"
  files:
    - .storybook/main.ts
    - .storybook/preview.tsx
    - .storybook/theme.ts
```

### Project Configuration
```ts
// .storybook/main.ts
import type { StorybookConfig } from '@storybook/nextjs';

const config: StorybookConfig = {
  stories: ['../**/*.mdx', '../**/*.stories.@(js|jsx|mjs|ts|tsx)'],
  addons: [
    '@storybook/addon-links',
    '@storybook/addon-essentials',
    '@storybook/addon-interactions',
    '@storybook/addon-a11y',
  ],
  framework: {
    name: '@storybook/nextjs',
    options: {},
  },
  docs: {
    autodocs: 'tag',
  },
};

export default config;
```

## Story File Structure
```tsx
// Component story file structure
import type { Meta, StoryObj } from '@storybook/react'
import { ComponentName } from './ComponentName'

const meta = {
  title: 'Category/ComponentName',
  component: ComponentName,
  tags: ['autodocs'],
  parameters: {
    layout: 'centered',
  },
} satisfies Meta<typeof ComponentName>

export default meta
type Story = StoryObj<typeof meta>

// Base story with default props
export const Default: Story = {
  args: {
    // Default props
  },
}

// Variants with different props
export const Variant: Story = {
  args: {
    // Variant-specific props
  },
}
```

## Story Organization

### Component Categories
```yaml
categories:
  atoms:        # Basic building blocks
    - Button
    - Input
    - Icon
  molecules:    # Combinations of atoms
    - SearchBar
    - Card
  organisms:    # Complex components
    - Header
    - Footer
  templates:    # Page layouts
    - DashboardLayout
    - AuthLayout
  pages:        # Full pages
    - HomePage
    - ProfilePage
```

### Naming Conventions
```yaml
naming:
  files: "{ComponentName}.stories.tsx"
  title: "Category/ComponentName"
  variants:
    - Default     # Base component
    - Primary     # Main variant
    - Secondary   # Alternative variant
    - Disabled    # State variant
    - Loading     # State variant
    - Error       # State variant
    - Sizes       # Size variants
    - Themes      # Theme variants
```

## Story Best Practices

### Component Documentation
```tsx
// Component story with documentation
const meta = {
  title: 'Components/Button',
  component: Button,
  tags: ['autodocs'],
  parameters: {
    componentSubtitle: 'Interactive button component',
    docs: {
      description: {
        component: 'A versatile button component that supports multiple variants and states.',
      },
    },
  },
  argTypes: {
    variant: {
      description: 'The visual style of the button',
      control: 'select',
      options: ['primary', 'secondary', 'ghost'],
      table: {
        type: { summary: 'string' },
        defaultValue: { summary: 'primary' },
      },
    },
    size: {
      description: 'The size of the button',
      control: 'radio',
      options: ['sm', 'md', 'lg'],
    },
    disabled: {
      description: 'Whether the button is disabled',
      control: 'boolean',
    },
  },
} satisfies Meta<typeof Button>
```

### Interactive Examples
```tsx
// Story with actions and controls
export const Interactive: Story = {
  args: {
    children: 'Click Me',
    onClick: action('clicked'),
  },
  parameters: {
    docs: {
      description: {
        story: 'An interactive example of the button component.',
      },
    },
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement)
    const button = canvas.getByRole('button')
    await userEvent.click(button)
  },
}
```

### State Management
```tsx
// Story with state management
export const WithState: Story = {
  render: function Render(args) {
    const [count, setCount] = useState(0)
    return (
      <Button {...args} onClick={() => setCount(count + 1)}>
        Count: {count}
      </Button>
    )
  },
}
```

## Testing Integration

### Component Testing
```tsx
// Story with testing
export const TestCase: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement)
    const button = canvas.getByRole('button')
    
    // Accessibility tests
    await expect(button).toHaveAttribute('aria-label')
    
    // Interaction tests
    await userEvent.click(button)
    await expect(button).toHaveClass('active')
    
    // State tests
    await userEvent.hover(button)
    await expect(button).toHaveStyle({ opacity: '0.8' })
  },
}
```

### Accessibility Testing
```tsx
// Story with a11y testing
const meta = {
  parameters: {
    a11y: {
      config: {
        rules: [
          { id: 'color-contrast', enabled: true },
          { id: 'label', enabled: true },
        ],
      },
    },
  },
}
```

## Composition Patterns

### Compound Components
```tsx
// Story for compound components
export const CompoundExample: Story = {
  render: () => (
    <Select>
      <Select.Trigger>Choose option</Select.Trigger>
      <Select.Content>
        <Select.Item value="1">Option 1</Select.Item>
        <Select.Item value="2">Option 2</Select.Item>
      </Select.Content>
    </Select>
  ),
}
```

### Context Integration
```tsx
// Story with context providers
export const WithContext: Story = {
  decorators: [
    (Story) => (
      <ThemeProvider theme="light">
        <Story />
      </ThemeProvider>
    ),
  ],
}
```

## Best Practices

1. Documentation:
   - Write clear component descriptions
   - Document all props with types and defaults
   - Include usage examples
   - Add accessibility guidelines

2. Organization:
   - Group related components
   - Use consistent naming
   - Maintain story hierarchy
   - Include relevant tags

3. Testing:
   - Include interaction tests
   - Test accessibility
   - Test responsive behavior
   - Test edge cases

4. Composition:
   - Show component composition
   - Demonstrate context usage
   - Include state management
   - Show integration patterns

5. Maintenance:
   - Keep stories up to date
   - Remove unused stories
   - Update documentation
   - Test regularly

## Common Patterns

### Preview Configuration
```tsx
// .storybook/preview.tsx
import type { Preview } from '@storybook/react';
import { withThemeByClassName } from '@storybook/addon-themes';
import '../app/globals.css';

const preview: Preview = {
  parameters: {
    actions: { argTypesRegex: '^on[A-Z].*' },
    controls: {
      matchers: {
        color: /(background|color)$/i,
        date: /Date$/,
      },
    },
  },
  decorators: [
    withThemeByClassName({
      themes: {
        light: 'light',
        dark: 'dark',
      },
      defaultTheme: 'light',
    }),
  ],
};

export default preview;
```

### Theme Configuration
```ts
// .storybook/theme.ts
import { create } from '@storybook/theming/create';

export default create({
  base: 'light',
  brandTitle: 'My Design System',
  brandUrl: 'https://example.com',
  brandImage: '/logo.svg',
  brandTarget: '_self',
});
```

### Testing Utilities
```ts
// .storybook/test-utils.ts
import { within, userEvent } from '@storybook/testing-library';

export const sleep = (ms: number) => 
  new Promise((resolve) => setTimeout(resolve, ms));

export async function clickButton(canvasElement: HTMLElement) {
  const canvas = within(canvasElement);
  const button = canvas.getByRole('button');
  await userEvent.click(button);
  return button;
}
```

## Component Development Methodology

### Component-Driven Development (CDD)
```yaml
principles:
  - Build UI from bottom up
  - Start with atomic components
  - Progress to composite components
  - End with full screens
  - Test in isolation
  - Document variations

development_flow:
  1_atomic:
    - Build basic components
    - Document states/variants
    - Test in isolation
  2_composite:
    - Combine basic components
    - Handle data flow
    - Test interactions
  3_screens:
    - Assemble full screens
    - Integrate with data
    - Test user flows
```

### Component States
```tsx
// Document all possible states
export const states = {
  default: 'Base component state',
  loading: 'Loading/skeleton state',
  error: 'Error state handling',
  empty: 'Empty/no data state',
  disabled: 'Disabled/inactive state',
  interactive: 'Interactive/hover/focus states',
  variations: 'Size/color/theme variations',
}

// Example implementation
export const ComponentStates: Story = {
  render: () => (
    <div className="states-wrapper">
      <Component {...Default.args} />
      <Component {...Loading.args} />
      <Component {...Error.args} />
      <Component {...Empty.args} />
    </div>
  ),
}
```

### Data Requirements
```tsx
// Define clear prop types
import PropTypes from 'prop-types'

ComponentName.propTypes = {
  /** Primary content */
  children: PropTypes.node.isRequired,
  /** Component visual style */
  variant: PropTypes.oneOf(['primary', 'secondary']),
  /** Loading state */
  isLoading: PropTypes.bool,
  /** Error state */
  error: PropTypes.shape({
    message: PropTypes.string,
  }),
  /** Click handler */
  onClick: PropTypes.func,
}

// TypeScript alternative
interface ComponentProps {
  /** Primary content */
  children: React.ReactNode;
  /** Component visual style */
  variant?: 'primary' | 'secondary';
  /** Loading state */
  isLoading?: boolean;
  /** Error state */
  error?: {
    message: string;
  };
  /** Click handler */
  onClick?: () => void;
}
```

### Testing Strategy
```yaml
testing_levels:
  visual:
    - Component appearance
    - Visual regression
    - Responsive behavior
    - Theme variations
  
  interaction:
    - User actions
    - State changes
    - Event handlers
    - Keyboard navigation
  
  accessibility:
    - WCAG compliance
    - Screen reader
    - Keyboard usage
    - Color contrast
  
  integration:
    - Data flow
    - Context usage
    - Side effects
    - Error boundaries
```

### Story Organization
```tsx
// Stories follow component complexity
stories:
  atoms: {
    Button: {
      states: ['default', 'hover', 'pressed', 'disabled'],
      variants: ['primary', 'secondary', 'ghost'],
    },
    Input: {
      states: ['default', 'focus', 'error', 'disabled'],
      variants: ['text', 'number', 'password'],
    },
  },
  molecules: {
    Form: {
      composition: ['Input', 'Button'],
      states: ['default', 'loading', 'success', 'error'],
    },
    Card: {
      composition: ['Image', 'Text', 'Button'],
      states: ['default', 'loading', 'expanded'],
    },
  },
  organisms: {
    Header: {
      composition: ['Logo', 'Navigation', 'Search', 'Profile'],
      states: ['default', 'authenticated', 'mobile'],
    },
  },
```

### Documentation Standards
```yaml
documentation:
  component:
    - Purpose and usage
    - Props/API reference
    - Examples and code snippets
    - Accessibility considerations
    - Performance notes
  
  story:
    - State description
    - Interaction guide
    - Technical notes
    - Edge cases
    - Known limitations
  
  integration:
    - Context requirements
    - Data dependencies
    - Event handling
    - State management
```

### Development Workflow
```yaml
workflow:
  1. Component Planning:
     - Define requirements
     - Identify states
     - Plan composition
     - Document API

  2. Implementation:
     - Build base component
     - Add variants
     - Implement states
     - Handle interactions

  3. Testing:
     - Visual tests
     - Interaction tests
     - A11y tests
     - Integration tests

  4. Documentation:
     - Write stories
     - Add descriptions
     - Include examples
     - Document edge cases

  5. Review & Iterate:
     - Peer review
     - Design review
     - Accessibility review
     - Performance review
```

## Testing Guidelines

### Test Setup
```yaml
setup:
  dependencies:
    - "@storybook/test": "latest"
    - "@storybook/addon-interactions": "latest"
    - "@storybook/addon-a11y": "latest"
    - "@storybook/test-runner": "latest"
    - "@storybook/addon-coverage": "latest"
  
  configuration:
    main:
      addons: 
        - "@storybook/addon-interactions"
        - "@storybook/addon-a11y"
        - "@storybook/addon-coverage"
    
    package.json:
      scripts:
        - "test-storybook": "test-storybook"
        - "test-storybook:ci": "test-storybook --maxWorkers=2"
```

### Component Testing
```tsx
// Component test example
import { userEvent, within, expect } from '@storybook/test';

export const LoginTest: Story = {
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    // Group related interactions
    await step('Enter credentials', async () => {
      await userEvent.type(canvas.getByTestId('email'), 'user@example.com');
      await userEvent.type(canvas.getByTestId('password'), 'password123');
    });

    await step('Submit form', async () => {
      await userEvent.click(canvas.getByRole('button'));
    });

    // Assert results
    await expect(
      canvas.getByText('Login successful')
    ).toBeInTheDocument();
  },
};

// Test with mocked modules
import { mockApi } from './api.mock';

export const MockedTest: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    await userEvent.click(canvas.getByRole('button'));
    await expect(mockApi.submit).toHaveBeenCalled();
  },
};
```

### Visual Testing
```yaml
visual_testing:
  tools:
    - Chromatic: Automated visual testing
    - Percy: Visual and DOM testing
    - Loki: Visual regression testing
    
  workflow:
    1. Baseline:
       - Capture initial component state
       - Document visual requirements
       - Set up testing thresholds
    
    2. Changes:
       - Automatically detect UI changes
       - Review visual differences
       - Update baselines when needed
    
    3. Regression:
       - Compare across viewports
       - Test different themes
       - Verify responsive behavior

  configuration:
    package.json:
      "chromatic": {
        "projectToken": "project-token",
        "buildScriptName": "build-storybook"
      }
```

### Accessibility Testing
```tsx
// A11y test configuration
const meta: Meta = {
  component: Button,
  parameters: {
    a11y: {
      config: {
        rules: [
          { id: 'color-contrast', enabled: true },
          { id: 'heading-order', enabled: true },
          { id: 'label', enabled: true },
        ],
      },
    },
  },
};

// A11y test example
export const AccessibleButton: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    const button = canvas.getByRole('button');
    
    // Test keyboard navigation
    await userEvent.tab();
    await expect(button).toHaveFocus();
    
    // Test ARIA attributes
    await expect(button).toHaveAttribute('aria-label');
    
    // Test color contrast
    await expect(
      await axeTest(canvasElement)
    ).toHaveNoViolations();
  },
};
```

### Snapshot Testing
```tsx
// Snapshot test setup
import initStoryshots from '@storybook/addon-storyshots';
import { render } from '@testing-library/react';

initStoryshots({
  framework: 'react',
  renderer: render,
  snapshotSerializers: [
    'jest-serializer-html',
  ],
});

// Custom snapshot serializer
const customSerializer = {
  test: (val: any) => typeof val === 'string',
  print: (val: string) => val.replace(/\s+/g, ' ').trim(),
};
```

### Test Runner Configuration
```yaml
test_runner:
  setup:
    - Install: npm install @storybook/test-runner --save-dev
    - Configure: Add test script to package.json
    - CI: Set up CI/CD pipeline integration
  
  options:
    - --maxWorkers: Limit concurrent tests
    - --shard: Split tests across CI jobs
    - --junit: Generate JUnit reports
    - --coverage: Enable code coverage
    
  ci_workflow:
    steps:
      - Install dependencies
      - Build Storybook
      - Run tests with coverage
      - Upload test reports
      - Store artifacts
```

### Test Coverage
```yaml
coverage:
  setup:
    - "@storybook/addon-coverage"
    - "istanbul"
    - "nyc"
  
  configuration:
    coverage:
      extends: "@istanbuljs/nyc-config-typescript"
      include:
        - "src/**/*.{js,jsx,ts,tsx}"
      exclude:
        - "src/**/*.stories.{js,jsx,ts,tsx}"
        - "src/**/*.test.{js,jsx,ts,tsx}"
  
  thresholds:
    statements: 80
    branches: 80
    functions: 80
    lines: 80
```

### Testing Best Practices
```yaml
best_practices:
  component_tests:
    - Test user interactions
    - Group related steps
    - Mock external dependencies
    - Assert state changes
    - Test error handling
  
  visual_tests:
    - Test across viewports
    - Include dark/light themes
    - Test loading states
    - Verify animations
    - Check responsive behavior
  
  a11y_tests:
    - Test keyboard navigation
    - Verify ARIA attributes
    - Check color contrast
    - Test screen readers
    - Validate heading structure
  
  snapshot_tests:
    - Keep snapshots focused
    - Review changes carefully
    - Update intentionally
    - Document changes
    - Use custom serializers
  
  general:
    - Write focused tests
    - Use meaningful assertions
    - Document test scenarios
    - Maintain test hygiene
    - Regular test reviews
```

### Continuous Integration
```yaml
ci_integration:
  workflow:
    setup:
      - Cache dependencies
      - Set up environment
      - Configure test runner
    
    test:
      - Run component tests
      - Run visual tests
      - Run a11y tests
      - Generate coverage
    
    report:
      - Upload test results
      - Store artifacts
      - Report coverage
      - Notify team
  
  example:
    name: Storybook Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
      - run: npm ci
      - run: npm run build-storybook
      - run: npm run test-storybook:ci
      - uses: actions/upload-artifact@v2
        with:
          name: storybook-test-results
          path: junit.xml
```

## Next.js Integration

### Framework Setup
```yaml
requirements:
  nextjs: "≥ 13.5"
  storybook: "≥ 7.0"
  dependencies:
    - "@storybook/nextjs": "latest"
    - "@storybook/addon-interactions": "latest"
    - "@storybook/test": "latest"

configuration:
  main:
    framework: "@storybook/nextjs"
    addons: [
      "@storybook/addon-links",
      "@storybook/addon-essentials",
      "@storybook/addon-interactions",
      "@storybook/addon-a11y"
    ]
```

### Next.js Components Support
```tsx
// Image Component Usage
import Image from 'next/image'

// Local images
export const LocalImage: Story = {
  render: () => (
    <Image
      src={require('../public/image.png')}
      alt="Description"
      // width and height automatically provided
      // blurDataURL set to equal the image itself
      placeholder="blur"
    />
  ),
}

// Remote images
export const RemoteImage: Story = {
  render: () => (
    <Image
      src="https://example.com/image.png"
      alt="Description"
      width={500}
      height={300}
    />
  ),
}

// Font Optimization
import { Inter } from 'next/font/google'
import localFont from 'next/font/local'

const inter = Inter({ subsets: ['latin'] })
const localSans = localFont({ src: './fonts/LocalSans.woff2' })
```

### Navigation and Routing
```tsx
// App Router Support
export const meta: Meta = {
  parameters: {
    nextjs: {
      appDirectory: true,
      navigation: {
        segments: ['dashboard', ['user', '123']],
        pathname: '/dashboard/user/123',
      },
    },
  },
}

// Router Mocking
import { getRouter } from '@storybook/nextjs/router.mock'

export const NavigationTest: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement)
    const backButton = canvas.getByRole('button', { name: /back/i })
    
    await userEvent.click(backButton)
    await expect(getRouter().back).toHaveBeenCalled()
  },
}
```

### API Mocking
```tsx
// API Route Mocking
import { mockApi } from '@storybook/nextjs/api.mock'

export const ApiTest: Story = {
  parameters: {
    nextjs: {
      api: {
        '/api/user': (req, res) => {
          return res.json({ name: 'John Doe' })
        },
      },
    },
  },
}

// Headers and Cookies
import { headers, cookies } from '@storybook/nextjs/headers.mock'

export const AuthenticatedState: Story = {
  parameters: {
    nextjs: {
      headers: () => {
        headers().set('authorization', 'Bearer token')
        cookies().set('user', 'john.doe')
      },
    },
  },
}
```

### Static Assets
```yaml
static_assets:
  configuration:
    main:
      staticDirs: ['../public']
      
  structure:
    public:
      - images/
      - fonts/
      - icons/
    
  usage:
    images: Use next/image component
    fonts: Configure in preview.tsx
    static: Direct import from public
```

### Environment Variables
```yaml
environment:
  configuration:
    env:
      - NEXT_PUBLIC_*: Available in stories
      - STORYBOOK_*: Storybook-specific
    
  setup:
    .env.storybook:
      NEXT_PUBLIC_API_URL=http://localhost:3000
      STORYBOOK_THEME=light
```

### Performance Optimization
```yaml
optimization:
  webpack:
    - Enable SWC
    - Optimize images
    - Bundle analysis
  
  vite:
    experimental: true
    requirements: "Next.js ≥ 14.1.0"
    setup:
      framework: "@storybook/experimental-nextjs-vite"
```

### Testing Considerations
```yaml
testing:
  setup:
    - Configure test-runner
    - Set up MSW for API mocking
    - Enable coverage reporting
  
  patterns:
    - Test App Router components
    - Mock server components
    - Test client components
    - Verify data fetching
    - Check routing behavior
```

### Best Practices
```yaml
nextjs_practices:
  structure:
    - Group stories by route
    - Match Next.js file structure
    - Separate server/client stories
    - Document data requirements
  
  components:
    - Test both SSR and CSR states
    - Mock server components
    - Handle loading states
    - Test error boundaries
    - Verify hydration
  
  data_fetching:
    - Mock API responses
    - Test loading states
    - Handle error states
    - Verify caching
    - Test revalidation
  
  routing:
    - Test navigation events
    - Verify route parameters
    - Check dynamic routes
    - Test middleware
    - Validate redirects
``` 